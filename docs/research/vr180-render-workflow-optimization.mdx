# VR180 Render Workflow Optimization

**Research Date:** 2025-12-07
**Topic:** Frame sequences vs direct render, crash safety, and optimization

---

## The Question

Should we:
1. **Render directly through compositor** to final H.265? (fast, risky)
2. **Render to frame sequences first**, then composite? (safe, professional)

**Answer: Frame sequences first!** Here's why:

---

## Workflow Comparison

### âŒ Direct Render (Current Spec - Not Recommended)

```
User clicks "Render for YouTube"
    â†“
Blender renders in real-time:
â”œâ”€â”€ Frame 1: Left eye â†’ Denoise â†’ Combine â†’ Encode
â”œâ”€â”€ Frame 2: Left eye â†’ Denoise â†’ Combine â†’ Encode
â”œâ”€â”€ Frame 3: Left eye â†’ Denoise â†’ Combine â†’ Encode
...
â””â”€â”€ Frame 1800: Left eye â†’ Denoise â†’ Combine â†’ Encode
    â†“
Output: final_youtube.mp4

ğŸ”´ CRASH at frame 1250?
   â†’ Lost ALL work, start over from frame 1!
```

**Problems:**
- âŒ No crash recovery
- âŒ Can't adjust compositing without full re-render
- âŒ Can't tweak denoising settings
- âŒ Can't extract individual frames
- âŒ Locked into one output format

---

### âœ… Frame Sequences (Recommended - Professional)

```
Step 1: Render Left Eye to OpenEXR sequence
â”œâ”€â”€ left_0001.exr (32-bit float HDR)
â”œâ”€â”€ left_0002.exr
â”œâ”€â”€ left_0003.exr
...
â””â”€â”€ left_1800.exr

ğŸ”´ CRASH? Resume from last completed frame! âœ…

Step 2: Render Right Eye to OpenEXR sequence
â”œâ”€â”€ right_0001.exr (32-bit float HDR)
â”œâ”€â”€ right_0002.exr
â”œâ”€â”€ right_0003.exr
...
â””â”€â”€ right_1800.exr

ğŸ”´ CRASH? Resume from last completed frame! âœ…

Step 3: Compositor reads sequences
â”œâ”€â”€ Load left_####.exr
â”œâ”€â”€ Load right_####.exr
â”œâ”€â”€ Denoise each eye
â”œâ”€â”€ Combine to SBS
â”œâ”€â”€ Color grade (optional)
â”œâ”€â”€ Encode H.265 @ 100Mbps
â””â”€â”€ Output: final_youtube.mp4

ğŸ”´ Compositing crashes or settings wrong?
   â†’ Just re-run compositor (30 seconds)!
   â†’ No re-render needed! âœ…
```

**Advantages:**
- âœ… **Crash-safe** - resume from any frame
- âœ… **Re-compositable** - tweak settings without re-render
- âœ… **Multiple outputs** - make 4K, 5.7K, 8K from same renders
- âœ… **Better quality** - 32-bit float HDR, no banding
- âœ… **Industry standard** - how professionals work
- âœ… **Debugging** - can inspect individual frames
- âœ… **Archival** - keep .exr sequences for future use

---

## Storage Comparison

### Example: 60-second video @ 60fps = 3,600 frames

**Direct Render:**
- Final output: ~5GB H.265
- No intermediate files
- **Total storage: 5GB**

**Frame Sequences:**
- Left eye: 3,600 Ã— 50MB = 180GB OpenEXR
- Right eye: 3,600 Ã— 50MB = 180GB OpenEXR
- Final output: ~5GB H.265
- **Total storage: 365GB** (before cleanup)

**After cleanup (delete .exr files):**
- **Total storage: 5GB** (same as direct)

**Verdict:** Yes, uses more space temporarily, but:
- Delete .exr after successful export
- Or keep .exr for archival (professional studios do this)
- Worth it for crash safety and flexibility!

---

## Render Time Comparison

### Direct Render
```
Total time: Render time only
Example: 60 min for 60-sec video

Risk: If crashes at 59 minutes â†’ lose 59 minutes of work
```

### Frame Sequence
```
Step 1: Render left eye    = 30 min
Step 2: Render right eye   = 30 min
Step 3: Composite          = 30 seconds
Total time: 60.5 min (slightly longer due to I/O)

Benefit: If crashes at 59 minutes â†’ only lose work since last frame!
Benefit: Re-compositing = 30 seconds (not 60 minutes)
```

**Verdict:** Slightly slower overall (~1% overhead), but MASSIVELY safer.

---

## OpenEXR vs PNG vs Direct Encode

### OpenEXR (Recommended)

**Specs:**
- 32-bit float per channel
- HDR (High Dynamic Range)
- No quality loss
- ~50MB per frame (2880Ã—2880)

**Pros:**
- âœ… Perfect quality preservation
- âœ… HDR for color grading
- âœ… Industry standard
- âœ… No banding or artifacts
- âœ… Can denoise later if needed

**Cons:**
- âŒ Large file sizes
- âŒ Slower to write/read

**Best for:** Professional work, archival, maximum quality

### PNG (Alternative)

**Specs:**
- 8-bit or 16-bit per channel
- LDR (Low Dynamic Range)
- Lossless compression
- ~10MB per frame (2880Ã—2880, 16-bit)

**Pros:**
- âœ… Smaller than OpenEXR
- âœ… Good quality (16-bit)
- âœ… Widely compatible

**Cons:**
- âŒ No HDR
- âŒ Banding in gradients (8-bit)
- âŒ Less color grading headroom

**Best for:** Budget workflows, preview renders

### Direct H.265 Encode (Not Recommended for VR180)

**Specs:**
- 8-bit or 10-bit per channel
- Lossy compression
- Small file size
- No frame recovery

**Pros:**
- âœ… Smallest files
- âœ… Fastest workflow

**Cons:**
- âŒ No crash recovery! ğŸ”´
- âŒ Can't re-composite
- âŒ Quality loss from compression
- âŒ No flexibility

**Best for:** Quick tests only, never final renders

---

## Recommended Workflow

### Option 1: Maximum Quality (Recommended)

```python
# Step 1: Render to OpenEXR sequences
left_scene.render.image_settings.file_format = 'OPEN_EXR'
left_scene.render.image_settings.color_depth = '32'
left_scene.render.image_settings.exr_codec = 'DWAA'  # Good compression
left_scene.render.filepath = "//renders/left_"

right_scene.render.image_settings.file_format = 'OPEN_EXR'
right_scene.render.image_settings.color_depth = '32'
right_scene.render.image_settings.exr_codec = 'DWAA'
right_scene.render.filepath = "//renders/right_"

# Render both sequences
bpy.ops.render.render(animation=True, scene='LeftScene')
bpy.ops.render.render(animation=True, scene='RightScene')

# Step 2: Compositor uses Image Sequence nodes
comp_scene = setup_compositor_with_sequences(
    left_path="//renders/left_####.exr",
    right_path="//renders/right_####.exr",
)

# Step 3: Render final output
comp_scene.render.image_settings.file_format = 'FFMPEG'
comp_scene.render.ffmpeg.codec = 'H265'
comp_scene.render.filepath = "//final_youtube.mp4"

bpy.ops.render.render(animation=True, scene='CompositorScene')

# Step 4: Cleanup (optional)
# Delete .exr files to save space
# Or keep them for archival
```

### Option 2: Balanced (16-bit PNG)

```python
# Same as above, but use PNG instead:
left_scene.render.image_settings.file_format = 'PNG'
left_scene.render.image_settings.color_depth = '16'
left_scene.render.image_settings.compression = 15  # 0-100, 15 is good

# 70% of OpenEXR quality, 20% of file size
```

### Option 3: Quick Preview (Not for final)

```python
# Direct render for quick tests only
# DO NOT use for final YouTube uploads!
comp_scene.render.image_settings.file_format = 'FFMPEG'
# ... render directly
```

---

## Compositor Setup for Sequences

### Using Image Sequence Nodes

```python
def setup_compositor_with_sequences(left_path, right_path):
    """
    Setup compositor to use pre-rendered OpenEXR sequences.

    This is MUCH better than rendering through compositor directly!
    """

    comp_scene = bpy.data.scenes.new("VR180_Compositor")
    comp_scene.use_nodes = True
    tree = comp_scene.node_tree

    # Clear default nodes
    for node in tree.nodes:
        tree.nodes.remove(node)

    # LEFT EYE: Image Sequence node (not RenderLayers!)
    left_seq = tree.nodes.new('CompositorNodeImage')
    left_seq.label = "Left Eye Sequence"
    left_seq.location = (-900, 300)

    # Load sequence
    left_images = []
    for i in range(comp_scene.frame_start, comp_scene.frame_end + 1):
        frame_path = left_path.replace("####", f"{i:04d}")
        img = bpy.data.images.load(frame_path)
        left_images.append(img)

    left_seq.image = left_images[0]  # Set first frame
    # TODO: Setup frame change handler to update image

    # RIGHT EYE: Image Sequence node
    right_seq = tree.nodes.new('CompositorNodeImage')
    right_seq.label = "Right Eye Sequence"
    right_seq.location = (-900, -300)
    # ... same as left

    # DENOISE nodes (per eye)
    dn_left = tree.nodes.new('CompositorNodeDenoise')
    dn_left.location = (-600, 300)

    dn_right = tree.nodes.new('CompositorNodeDenoise')
    dn_right.location = (-600, -300)

    # ... rest of compositor setup same as before

    return comp_scene
```

**Note:** Blender's Image Sequence node is simpler - just point it at the sequence and it handles frame changes automatically!

---

## Crash Recovery

### With Frame Sequences

```python
def resume_render_from_crash(scene, last_completed_frame):
    """Resume rendering after crash."""

    # Set start frame to next incomplete frame
    scene.frame_start = last_completed_frame + 1

    # Continue rendering
    bpy.ops.render.render(animation=True)

    print(f"Resumed from frame {last_completed_frame + 1}")
```

**Auto-detection:**
```python
def find_last_completed_frame(output_path):
    """Find highest numbered frame file."""

    import os
    import re

    files = os.listdir(os.path.dirname(output_path))
    pattern = r"left_(\d{4})\.exr"

    frames = []
    for f in files:
        match = re.match(pattern, f)
        if match:
            frames.append(int(match.group(1)))

    if frames:
        return max(frames)
    else:
        return 0  # No frames found, start from beginning
```

---

## Best Practices Summary

### âœ… DO:

1. **Render to OpenEXR sequences first**
   - Left eye: `renders/left_####.exr`
   - Right eye: `renders/right_####.exr`

2. **Use compositor to read sequences**
   - Image Sequence nodes, not RenderLayers
   - Allows re-compositing without re-render

3. **Output final as H.265**
   - 100Mbps bitrate
   - With VR180 metadata

4. **Keep .exr for archival** (optional but recommended)
   - Can make different exports later
   - 4K, 5.7K, 8K from same source
   - Re-grade color anytime

5. **Enable auto-save in Blender**
   - Preferences â†’ Auto-save every 5 minutes
   - Crash recovery for .blend file too

### âŒ DON'T:

1. **Don't render directly to H.265**
   - No crash recovery
   - Can't re-composite
   - Quality loss

2. **Don't use 8-bit PNG**
   - Banding in gradients
   - Use 16-bit PNG minimum, or OpenEXR

3. **Don't delete .exr until final is verified**
   - Watch full video in VR headset first
   - Check for issues
   - Then delete .exr to save space

---

## Storage Planning

### Example Project: 5-minute VR180 video @ 60fps

**Frame count:** 5 min Ã— 60fps = 18,000 frames

**Storage needed:**

| Stage | File Type | Size per Frame | Total Size |
|-------|-----------|----------------|------------|
| **Left eye render** | OpenEXR 32-bit | 50MB | 900GB |
| **Right eye render** | OpenEXR 32-bit | 50MB | 900GB |
| **Final output** | H.265 100Mbps | - | 25GB |
| **Total (during)** | - | - | **1,825GB** |
| **Total (after cleanup)** | - | - | **25GB** |

**Recommendation:**
- 2TB fast SSD for rendering
- Delete .exr after final export verified
- Or move .exr to archival storage (HDD)

---

## Workflow Automation

### Add-on Should Provide:

**Render Modes:**

1. **"Quick Preview"** (for testing)
   - Direct render to H.265
   - Low samples (128)
   - Fast, no crash safety

2. **"Production"** (recommended)
   - Render to 16-bit PNG sequences
   - Composite to H.265
   - Crash-safe, good quality

3. **"Final/Archival"** (highest quality)
   - Render to OpenEXR 32-bit sequences
   - Composite to H.265
   - Keep .exr for archival

**UI Example:**
```
[ ] Quick Preview (fast, no crash safety)
[â—] Production (recommended - 16-bit PNG)
[ ] Final/Archival (OpenEXR, keep sequences)

[Render for YouTube]
```

---

## Conclusion

**Recommended Workflow:**

```
1. Render left/right to OpenEXR sequences
   âœ… Crash-safe
   âœ… Re-compositable
   âœ… Maximum quality

2. Compositor reads sequences
   âœ… Fast re-compositing
   âœ… Flexible adjustments

3. Export to H.265 with metadata
   âœ… YouTube-ready

4. Delete .exr files (or archive)
   âœ… Save storage
   âœ… Or keep for future exports
```

**Storage cost:** ~2TB during render, 25GB after cleanup (for 5-min video)

**Time cost:** +1% overhead vs direct render

**Benefits:** Crash safety, re-compositing, flexibility, industry standard

**Worth it?** Absolutely! Professional studios ALWAYS use frame sequences.

---

## Implementation Priority

**For Add-on v1.0:**
- âœ… Implement frame sequence workflow
- âœ… OpenEXR option
- âœ… 16-bit PNG option (default)
- âœ… Auto-cleanup option
- âœ… Resume from crash detection

**For Add-on v1.1+:**
- â­ï¸ Direct render option (for quick tests)
- â­ï¸ Custom .exr codec selection
- â­ï¸ Automatic archival to HDD

---

**This is the professional way. Let's do it right!**
