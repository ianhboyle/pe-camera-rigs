---
title: "Isometric Camera: Code & Implementation"
description: "Code specification for the interactive, Geometry Nodes-based Live Controller rig."
status: Planning
priority: High
---

# Isometric Camera: Code & Implementation

**See also:**
- [← Part 1: Live Controller Workflow & UX](./isometric-01-userflow-and-ux.mdx)

---

## Overview

This document outlines the Python and Geometry Nodes implementation for the **Live Controller Workflow**. We will replace the previous multi-operator system with a single operator that creates a smart, Geometry Nodes-based rig.

**Key Implementation Features:**
- **Single Operator:** A single `ISOMETRIC_OT_add_controller` to create the entire rig.
- **Controller Object:** A parent empty object will serve as the main controller.
- **Geometry Nodes Modifier:** The controller will have a Geometry Nodes modifier attached.
- **Geometry Nodes Logic:** The camera's rotation and orthographic scale will be procedurally driven by the Geometry Nodes modifier's inputs, enabling real-time updates.
- **Context-Sensitive UI:** A clean UI panel will appear in the Object Properties tab, prompting the user to select the controller and use its Modifier Properties tab.

---

## File Structure

All new Isometric Camera code will be placed in a dedicated module: `src/pe_camera_rigs/isometric/`.

- `__init__.py`: Handles registration for this module.
- `operators.py`: Contains `ISOMETRIC_OT_add_controller`.
- `panels.py`: Contains the UI panels.
- `properties.py`: Contains the PropertyGroup for the camera settings.
- `nodes.py`: Contains functions to programmatically create the Geometry Node group.

---

## 1. Main Operator

### File: `isometric/operators.py`

We only need one operator to create the controller rig.

```python
import bpy
from .properties import (
    PE_IsometricCameraSettings,
    PROJECTION_TYPES
)
from .nodes import create_isometric_camera_node_group # New import

class ISOMETRIC_OT_add_controller(bpy.types.Operator):
    """Adds an Isometric Camera Controller to the scene"""
    bl_idname = "cgt.add_isometric_controller"
    bl_label = "Add Isometric Controller"
    bl_description = "Creates an interactive, Geometry Nodes-based isometric camera rig"
    bl_options = {'REGISTER', 'UNDO'}

    # Property to set the initial preset from the UI
    initial_preset: bpy.props.EnumProperty(
        name="Preset",
        items=PROJECTION_TYPES,
        default='TRUE_ISOMETRIC'
    )

    def execute(self, context):
        # 1. Create a template camera data-block (hidden, used by GeoNodes)
        #    This is critical because GN can instance objects but not create new Camera data.
        template_cam_data = bpy.data.cameras.new(name="Isometric_Template_CamData")
        template_cam_obj = bpy.data.objects.new(name="Isometric_Template_Cam", object_data=template_cam_data)
        template_cam_data.type = 'ORTHO' # Set orthographic here
        
        # Hide the template object from view and render
        template_cam_obj.hide_set(True)
        template_cam_obj.hide_render = True
        context.collection.objects.link(template_cam_obj) # Link it so it saves

        # 2. Create the Geometry Node group for the isometric logic
        node_group = create_isometric_camera_node_group()

        # 3. Create the controller object (an empty)
        controller = bpy.data.objects.new(name="Isometric_Controller", object_data=None)
        controller.empty_display_type = 'CUBE'
        controller.empty_display_size = 0.5
        context.collection.objects.link(controller)

        # 4. Add the Geometry Nodes modifier
        mod = controller.modifiers.new(name="Isometric Camera", type='NODES')
        mod.node_group = node_group

        # 5. Set initial values on the modifier from our presets
        # These inputs correspond to the Geometry Node group's interface
        # The exact input names/indices will depend on the node group definition
        # For this spec, we'll use assumed names that match the inputs defined in nodes.py
        mod["Socket_Input_CameraTemplate"] = template_cam_obj
        mod["Socket_Input_ProjectionType"] = self.initial_preset
        mod["Socket_Input_OrthoScale"] = 14.0 # Default value, can be overridden by preset logic in operator
        
        # 6. Make the new rig active
        bpy.ops.object.select_all(action='DESELECT')
        context.view_layer.objects.active = controller
        controller.select_set(True)
        
        # Set the scene camera to the one generated by Geometry Nodes.
        # This is tricky; a robust implementation would involve tagging the output.
        # For this spec, we'll assume the GN modifier always generates a camera
        # and we can find it as the *first* instance of a camera from the controller.
        generated_cam_obj = None
        for obj in context.view_layer.objects: # Search for the instanced camera
            if obj.parent == controller and obj.data and obj.data.type == 'CAMERA': # Simplified check
                generated_cam_obj = obj
                break

        if generated_cam_obj:
            context.scene.camera = generated_cam_obj
        else:
            self.report({'WARNING'}, "Isometric Camera not found after creation. Set manually.")

        self.report({'INFO'}, f"Isometric Controller created with '{self.initial_preset}' preset.")
        return {'FINISHED'}```

---

## 2. Properties & Node Group

### File: `isometric/properties.py`

This file defines the custom properties that will be attached to our controller object. These are primarily for the initial setup via the operator.

```python
import bpy
import math

PROJECTION_TYPES = [
    ('GAME_2_1', "Game (2:1 Ratio)", "26.565° tilt for 2:1 pixel art"),
    ('GAME_4_3', "Game (4:3 Ratio)", "30° tilt for 4:3 pixel art"),
    ('TRUE_ISOMETRIC', "True Isometric", "35.264° tilt, mathematically correct"),
    ('DIMETRIC', "Dimetric (30°)", "30° tilt, a common artistic variation"),
    ('MILITARY', "Military (Top-Down)", "90° tilt for a top-down view"),
    ('CUSTOM', "Custom", "Use custom rotation and tilt values"),
]

class PE_IsometricCameraSettings(bpy.types.PropertyGroup):
    """Defines the settings for the isometric camera controller.
    These are primarily used for the initial setup by the operator."""
    
    projection_type: bpy.props.EnumProperty(
        name="Projection Type",
        items=PROJECTION_TYPES,
        default='TRUE_ISOMETRIC',
        description="Select the isometric projection style"
    )
    
    ortho_scale: bpy.props.FloatProperty(
        name="Ortho Scale (Zoom)",
        default=14.0,
        min=0.01,
        soft_max=100.0,
        description="Controls the zoom level of the orthographic camera"
    )
    
    # ... other properties like custom angles, guide toggles etc. (these will be GN inputs)
```

### File: `isometric/nodes.py`

This is where the Geometry Nodes magic happens. A Python function here programmatically builds the entire node tree for the procedural camera and its guide elements.

```python
import bpy

def create_isometric_camera_node_group():
    """
    Creates the Geometry Node group that procedurally generates the isometric
    camera and guide elements.
    """
    node_group_name = "GN_Isometric_Camera_Rig"
    if node_group_name in bpy.data.node_groups:
        return bpy.data.node_groups[node_group_name]

    node_group = bpy.data.node_groups.new(name=node_group_name, type='GeometryNodeTree')
    nodes = node_group.nodes
    links = node_group.links

    # Clear default nodes
    for node in nodes:
        nodes.remove(node)

    # === Group Inputs (The Modifier Interface) ===
    input_node = nodes.new('NodeGroupInput')
    input_node.location = (-1200, 0)

    # Inputs based on the UX specification:
    # 0: Camera Template Object (an object that has Camera Data)
    input_node.outputs.new('NodeSocketObject', "Camera Template Object")
    
    # 1: Projection Type (Enum)
    # This would typically be an integer input in GN, mapped to specific angle sets.
    # The operator would convert the EnumProperty string to an integer index.
    input_node.outputs.new('NodeSocketInt', "Projection Type").default_value = 0 # Default to first item
    
    # 2: Ortho Scale
    input_node.outputs.new('NodeSocketFloat', "Ortho Scale (Zoom)").default_value = 14.0
    
    # 3-5: Custom Angles (only active when Projection Type is 'Custom')
    input_node.outputs.new('NodeSocketFloat', "Custom Rotation Z").default_value = 0.0
    input_node.outputs.new('NodeSocketFloat', "Custom Tilt X").default_value = 0.0
    input_node.outputs.new('NodeSocketFloat', "Custom Roll Y").default_value = 0.0

    # 6-7: Procedural Guides
    input_node.outputs.new('NodeSocketBool', "Show Reference Grid").default_value = False
    input_node.outputs.new('NodeSocketBool', "Show Axis Indicators").default_value = False
    
    # === Group Outputs ===
    output_node = nodes.new('NodeGroupOutput')
    output_node.location = (1000, 0)
    output_node.inputs.new('NodeSocketGeometry', "Camera Rig Geometry")

    # === Node Tree Logic (High-Level Description) ===
    # 1. Take the "Camera Template Object" and instance it.
    # 2. Based on the "Projection Type" input (and "Custom Angles" if applicable),
    #    calculate the appropriate rotation for the instanced camera.
    # 3. Apply the "Ortho Scale" to the camera.
    # 4. Generate mesh primitives for "Reference Grid" and "Axis Indicators" based on boolean toggles.
    # 5. Join the instanced camera with the generated guides.
    # 6. Output the combined geometry.

    # Note: Detailed node setup is omitted for brevity in this spec, as the Blender GN API is rapidly evolving.
    # The Python function's primary role is to set up the group, its inputs, and a high-level structure.
    # The internal connections would be programmatically created here.

    return node_group

---

## 3. UI Panels

### File: `isometric/panels.py`

The UI panels are simplified as the primary controls are now within the Geometry Nodes modifier. We need a simple panel in the 3D View Sidebar to add the rig, and a more detailed panel in the Object Properties that points the user to the modifier.

```python
import bpy

class ISOMETRIC_PT_add_panel(bpy.types.Panel):
    """Creates a Panel in the 3D Viewport Sidebar"""
    bl_label = "Isometric Camera"
    bl_idname = "ISOMETRIC_PT_add_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'PE Cams' # New category for all our camera tools

    def draw(self, context):
        layout = self.layout
        # Simple button to add the controller
        layout.operator("cgt.add_isometric_controller", icon='CAMERA_DATA')

class ISOMETRIC_PT_controller_settings(bpy.types.Panel):
    """Draws the UI in the Object Properties panel"""
    bl_label = "Isometric Camera Controller"
    bl_idname = "ISOMETRIC_PT_controller_settings"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "object"

    @classmethod
    def poll(cls, context):
        # Only show this panel if the active object is the Isometric Controller
        # AND has our Geometry Nodes modifier.
        obj = context.object
        return (obj is not None and obj.name.startswith("Isometric_Controller") and 
                any(m.type == 'NODES' and m.node_group and m.node_group.name == "GN_Isometric_Camera_Rig" for m in obj.modifiers))

    def draw(self, context):
        layout = self.layout
        # Point the user to the Modifier Properties
        layout.label(text="Adjust settings in Modifier Properties", icon='MODIFIER')
        layout.operator("wm.context_set_string", text="Go to Modifier Tab", icon='PREFERENCES').data_path = "window.current_menu_string"
        layout.operator("wm.context_set_enum", text="Go to Modifier Tab", icon='MODIFIER').data_path = "area.type"; layout.operator("wm.context_set_enum", text="", icon='MODIFIER').value = "PROPERTIES"; layout.operator("wm.context_set_string", text="", icon='MODIFIER').data_path = "properties_data.context"; layout.operator("wm.context_set_string", text="", icon='MODIFIER').value = "OBJECT_MODIFIER"

```

---

## Summary of Changes

The implementation has shifted from a driver-based approach to a procedural, Geometry Nodes-based one.

1.  **Consolidated Operator:** All creation logic is now in `ISOMETRIC_OT_add_controller`, which primarily sets up the Geometry Nodes modifier.
2.  **Live Properties:** Camera settings are no longer static values set once by Python. They are now live, animatable inputs on the Geometry Nodes modifier.
3.  **Geometry Nodes Logic:** The core logic of linking presets to angles and generating camera transforms is handled by Blender's Geometry Nodes system, which is efficient and updates in real-time.
4.  **Simplified Python:** The Python code is now simpler, as its main job is to create the controller object and configure its Geometry Nodes modifier.
5.  **Contextual UI:** The UI is smarter. The main settings are found directly on the controller's Modifier Properties panel, aligning with standard Blender workflows.
